/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.shippo.sdk.models.components;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.shippo.sdk.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;


public class Batch {

    /**
     * ID of the Carrier Account object to use as the default for all shipments in this Batch. 
     * The carrier account can be changed on a per-shipment basis by changing the carrier_account in the 
     * corresponding BatchShipment object.
     */
    @JsonProperty("default_carrier_account")
    private String defaultCarrierAccount;

    /**
     * Token of the service level to use as the default for all shipments in this Batch. 
     * The servicelevel can be changed on a per-shipment basis by changing the servicelevel_token in the 
     * corresponding BatchShipment object. &lt;a href="#tag/Service-Levels"&gt;Servicelevel tokens can be found here.&lt;/a&gt;
     */
    @JsonProperty("default_servicelevel_token")
    private String defaultServicelevelToken;

    /**
     * Print format of the &lt;a href="https://docs.goshippo.com/docs/shipments/shippinglabelsizes/"&gt;label&lt;/a&gt;. If empty, will use the default format set from 
     * &lt;a href="https://apps.goshippo.com/settings/labels"&gt;the Shippo dashboard.&lt;/a&gt;
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("label_filetype")
    private Optional<? extends LabelFileTypeEnum> labelFiletype;

    /**
     * A string of up to 100 characters that can be filled with any additional information you want to attach to the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private Optional<String> metadata;

    @JsonProperty("batch_shipments")
    private BatchShipmentPaginatedList batchShipments;

    /**
     * An array of URLs each pointing to a merged file of 100 labels each
     */
    @JsonProperty("label_url")
    private List<String> labelUrl;

    /**
     * Date and time of Batch creation
     */
    @JsonProperty("object_created")
    private String objectCreated;

    /**
     * Unique identifier of the given Batch object
     */
    @JsonProperty("object_id")
    private String objectId;

    /**
     * Username of the user who created the Address object.
     */
    @JsonProperty("object_owner")
    private String objectOwner;

    /**
     * An object containing the following counts:&lt;br&gt;`creation_succeeded`&lt;br&gt;`creation_failed`&lt;br&gt;`purchase_succeeded`&lt;br&gt;`purchase_failed`
     */
    @JsonProperty("object_results")
    private ObjectResults objectResults;

    /**
     * Date and time of last update to the Batch
     */
    @JsonProperty("object_updated")
    private String objectUpdated;

    /**
     * Batches that are `VALIDATING` are being created and validated&lt;br&gt;
     * `VALID` batches can be purchased&lt;br&gt;
     * `INVALID` batches cannot be purchased, `INVALID` BatchShipments must be removed&lt;br&gt;
     * Batches that are in the `PURCHASING` state are being purchased&lt;br&gt;
     * `PURCHASED` batches are finished purchasing.
     */
    @JsonProperty("status")
    private BatchStatus status;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("test")
    private Optional<Boolean> test;

    @JsonCreator
    public Batch(
            @JsonProperty("default_carrier_account") String defaultCarrierAccount,
            @JsonProperty("default_servicelevel_token") String defaultServicelevelToken,
            @JsonProperty("label_filetype") Optional<? extends LabelFileTypeEnum> labelFiletype,
            @JsonProperty("metadata") Optional<String> metadata,
            @JsonProperty("batch_shipments") BatchShipmentPaginatedList batchShipments,
            @JsonProperty("label_url") List<String> labelUrl,
            @JsonProperty("object_created") String objectCreated,
            @JsonProperty("object_id") String objectId,
            @JsonProperty("object_owner") String objectOwner,
            @JsonProperty("object_results") ObjectResults objectResults,
            @JsonProperty("object_updated") String objectUpdated,
            @JsonProperty("status") BatchStatus status,
            @JsonProperty("test") Optional<Boolean> test) {
        Utils.checkNotNull(defaultCarrierAccount, "defaultCarrierAccount");
        Utils.checkNotNull(defaultServicelevelToken, "defaultServicelevelToken");
        Utils.checkNotNull(labelFiletype, "labelFiletype");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(batchShipments, "batchShipments");
        Utils.checkNotNull(labelUrl, "labelUrl");
        Utils.checkNotNull(objectCreated, "objectCreated");
        Utils.checkNotNull(objectId, "objectId");
        Utils.checkNotNull(objectOwner, "objectOwner");
        Utils.checkNotNull(objectResults, "objectResults");
        Utils.checkNotNull(objectUpdated, "objectUpdated");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(test, "test");
        this.defaultCarrierAccount = defaultCarrierAccount;
        this.defaultServicelevelToken = defaultServicelevelToken;
        this.labelFiletype = labelFiletype;
        this.metadata = metadata;
        this.batchShipments = batchShipments;
        this.labelUrl = labelUrl;
        this.objectCreated = objectCreated;
        this.objectId = objectId;
        this.objectOwner = objectOwner;
        this.objectResults = objectResults;
        this.objectUpdated = objectUpdated;
        this.status = status;
        this.test = test;
    }
    
    public Batch(
            String defaultCarrierAccount,
            String defaultServicelevelToken,
            BatchShipmentPaginatedList batchShipments,
            List<String> labelUrl,
            String objectCreated,
            String objectId,
            String objectOwner,
            ObjectResults objectResults,
            String objectUpdated,
            BatchStatus status) {
        this(defaultCarrierAccount, defaultServicelevelToken, Optional.empty(), Optional.empty(), batchShipments, labelUrl, objectCreated, objectId, objectOwner, objectResults, objectUpdated, status, Optional.empty());
    }

    /**
     * ID of the Carrier Account object to use as the default for all shipments in this Batch. 
     * The carrier account can be changed on a per-shipment basis by changing the carrier_account in the 
     * corresponding BatchShipment object.
     */
    @JsonIgnore
    public String defaultCarrierAccount() {
        return defaultCarrierAccount;
    }

    /**
     * Token of the service level to use as the default for all shipments in this Batch. 
     * The servicelevel can be changed on a per-shipment basis by changing the servicelevel_token in the 
     * corresponding BatchShipment object. &lt;a href="#tag/Service-Levels"&gt;Servicelevel tokens can be found here.&lt;/a&gt;
     */
    @JsonIgnore
    public String defaultServicelevelToken() {
        return defaultServicelevelToken;
    }

    /**
     * Print format of the &lt;a href="https://docs.goshippo.com/docs/shipments/shippinglabelsizes/"&gt;label&lt;/a&gt;. If empty, will use the default format set from 
     * &lt;a href="https://apps.goshippo.com/settings/labels"&gt;the Shippo dashboard.&lt;/a&gt;
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<LabelFileTypeEnum> labelFiletype() {
        return (Optional<LabelFileTypeEnum>) labelFiletype;
    }

    /**
     * A string of up to 100 characters that can be filled with any additional information you want to attach to the object.
     */
    @JsonIgnore
    public Optional<String> metadata() {
        return metadata;
    }

    @JsonIgnore
    public BatchShipmentPaginatedList batchShipments() {
        return batchShipments;
    }

    /**
     * An array of URLs each pointing to a merged file of 100 labels each
     */
    @JsonIgnore
    public List<String> labelUrl() {
        return labelUrl;
    }

    /**
     * Date and time of Batch creation
     */
    @JsonIgnore
    public String objectCreated() {
        return objectCreated;
    }

    /**
     * Unique identifier of the given Batch object
     */
    @JsonIgnore
    public String objectId() {
        return objectId;
    }

    /**
     * Username of the user who created the Address object.
     */
    @JsonIgnore
    public String objectOwner() {
        return objectOwner;
    }

    /**
     * An object containing the following counts:&lt;br&gt;`creation_succeeded`&lt;br&gt;`creation_failed`&lt;br&gt;`purchase_succeeded`&lt;br&gt;`purchase_failed`
     */
    @JsonIgnore
    public ObjectResults objectResults() {
        return objectResults;
    }

    /**
     * Date and time of last update to the Batch
     */
    @JsonIgnore
    public String objectUpdated() {
        return objectUpdated;
    }

    /**
     * Batches that are `VALIDATING` are being created and validated&lt;br&gt;
     * `VALID` batches can be purchased&lt;br&gt;
     * `INVALID` batches cannot be purchased, `INVALID` BatchShipments must be removed&lt;br&gt;
     * Batches that are in the `PURCHASING` state are being purchased&lt;br&gt;
     * `PURCHASED` batches are finished purchasing.
     */
    @JsonIgnore
    public BatchStatus status() {
        return status;
    }

    @JsonIgnore
    public Optional<Boolean> test() {
        return test;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * ID of the Carrier Account object to use as the default for all shipments in this Batch. 
     * The carrier account can be changed on a per-shipment basis by changing the carrier_account in the 
     * corresponding BatchShipment object.
     */
    public Batch withDefaultCarrierAccount(String defaultCarrierAccount) {
        Utils.checkNotNull(defaultCarrierAccount, "defaultCarrierAccount");
        this.defaultCarrierAccount = defaultCarrierAccount;
        return this;
    }

    /**
     * Token of the service level to use as the default for all shipments in this Batch. 
     * The servicelevel can be changed on a per-shipment basis by changing the servicelevel_token in the 
     * corresponding BatchShipment object. &lt;a href="#tag/Service-Levels"&gt;Servicelevel tokens can be found here.&lt;/a&gt;
     */
    public Batch withDefaultServicelevelToken(String defaultServicelevelToken) {
        Utils.checkNotNull(defaultServicelevelToken, "defaultServicelevelToken");
        this.defaultServicelevelToken = defaultServicelevelToken;
        return this;
    }

    /**
     * Print format of the &lt;a href="https://docs.goshippo.com/docs/shipments/shippinglabelsizes/"&gt;label&lt;/a&gt;. If empty, will use the default format set from 
     * &lt;a href="https://apps.goshippo.com/settings/labels"&gt;the Shippo dashboard.&lt;/a&gt;
     */
    public Batch withLabelFiletype(LabelFileTypeEnum labelFiletype) {
        Utils.checkNotNull(labelFiletype, "labelFiletype");
        this.labelFiletype = Optional.ofNullable(labelFiletype);
        return this;
    }

    /**
     * Print format of the &lt;a href="https://docs.goshippo.com/docs/shipments/shippinglabelsizes/"&gt;label&lt;/a&gt;. If empty, will use the default format set from 
     * &lt;a href="https://apps.goshippo.com/settings/labels"&gt;the Shippo dashboard.&lt;/a&gt;
     */
    public Batch withLabelFiletype(Optional<? extends LabelFileTypeEnum> labelFiletype) {
        Utils.checkNotNull(labelFiletype, "labelFiletype");
        this.labelFiletype = labelFiletype;
        return this;
    }

    /**
     * A string of up to 100 characters that can be filled with any additional information you want to attach to the object.
     */
    public Batch withMetadata(String metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = Optional.ofNullable(metadata);
        return this;
    }

    /**
     * A string of up to 100 characters that can be filled with any additional information you want to attach to the object.
     */
    public Batch withMetadata(Optional<String> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    public Batch withBatchShipments(BatchShipmentPaginatedList batchShipments) {
        Utils.checkNotNull(batchShipments, "batchShipments");
        this.batchShipments = batchShipments;
        return this;
    }

    /**
     * An array of URLs each pointing to a merged file of 100 labels each
     */
    public Batch withLabelUrl(List<String> labelUrl) {
        Utils.checkNotNull(labelUrl, "labelUrl");
        this.labelUrl = labelUrl;
        return this;
    }

    /**
     * Date and time of Batch creation
     */
    public Batch withObjectCreated(String objectCreated) {
        Utils.checkNotNull(objectCreated, "objectCreated");
        this.objectCreated = objectCreated;
        return this;
    }

    /**
     * Unique identifier of the given Batch object
     */
    public Batch withObjectId(String objectId) {
        Utils.checkNotNull(objectId, "objectId");
        this.objectId = objectId;
        return this;
    }

    /**
     * Username of the user who created the Address object.
     */
    public Batch withObjectOwner(String objectOwner) {
        Utils.checkNotNull(objectOwner, "objectOwner");
        this.objectOwner = objectOwner;
        return this;
    }

    /**
     * An object containing the following counts:&lt;br&gt;`creation_succeeded`&lt;br&gt;`creation_failed`&lt;br&gt;`purchase_succeeded`&lt;br&gt;`purchase_failed`
     */
    public Batch withObjectResults(ObjectResults objectResults) {
        Utils.checkNotNull(objectResults, "objectResults");
        this.objectResults = objectResults;
        return this;
    }

    /**
     * Date and time of last update to the Batch
     */
    public Batch withObjectUpdated(String objectUpdated) {
        Utils.checkNotNull(objectUpdated, "objectUpdated");
        this.objectUpdated = objectUpdated;
        return this;
    }

    /**
     * Batches that are `VALIDATING` are being created and validated&lt;br&gt;
     * `VALID` batches can be purchased&lt;br&gt;
     * `INVALID` batches cannot be purchased, `INVALID` BatchShipments must be removed&lt;br&gt;
     * Batches that are in the `PURCHASING` state are being purchased&lt;br&gt;
     * `PURCHASED` batches are finished purchasing.
     */
    public Batch withStatus(BatchStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    public Batch withTest(boolean test) {
        Utils.checkNotNull(test, "test");
        this.test = Optional.ofNullable(test);
        return this;
    }

    public Batch withTest(Optional<Boolean> test) {
        Utils.checkNotNull(test, "test");
        this.test = test;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Batch other = (Batch) o;
        return 
            Objects.deepEquals(this.defaultCarrierAccount, other.defaultCarrierAccount) &&
            Objects.deepEquals(this.defaultServicelevelToken, other.defaultServicelevelToken) &&
            Objects.deepEquals(this.labelFiletype, other.labelFiletype) &&
            Objects.deepEquals(this.metadata, other.metadata) &&
            Objects.deepEquals(this.batchShipments, other.batchShipments) &&
            Objects.deepEquals(this.labelUrl, other.labelUrl) &&
            Objects.deepEquals(this.objectCreated, other.objectCreated) &&
            Objects.deepEquals(this.objectId, other.objectId) &&
            Objects.deepEquals(this.objectOwner, other.objectOwner) &&
            Objects.deepEquals(this.objectResults, other.objectResults) &&
            Objects.deepEquals(this.objectUpdated, other.objectUpdated) &&
            Objects.deepEquals(this.status, other.status) &&
            Objects.deepEquals(this.test, other.test);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            defaultCarrierAccount,
            defaultServicelevelToken,
            labelFiletype,
            metadata,
            batchShipments,
            labelUrl,
            objectCreated,
            objectId,
            objectOwner,
            objectResults,
            objectUpdated,
            status,
            test);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Batch.class,
                "defaultCarrierAccount", defaultCarrierAccount,
                "defaultServicelevelToken", defaultServicelevelToken,
                "labelFiletype", labelFiletype,
                "metadata", metadata,
                "batchShipments", batchShipments,
                "labelUrl", labelUrl,
                "objectCreated", objectCreated,
                "objectId", objectId,
                "objectOwner", objectOwner,
                "objectResults", objectResults,
                "objectUpdated", objectUpdated,
                "status", status,
                "test", test);
    }
    
    public final static class Builder {
 
        private String defaultCarrierAccount;
 
        private String defaultServicelevelToken;
 
        private Optional<? extends LabelFileTypeEnum> labelFiletype = Optional.empty();
 
        private Optional<String> metadata = Optional.empty();
 
        private BatchShipmentPaginatedList batchShipments;
 
        private List<String> labelUrl;
 
        private String objectCreated;
 
        private String objectId;
 
        private String objectOwner;
 
        private ObjectResults objectResults;
 
        private String objectUpdated;
 
        private BatchStatus status;
 
        private Optional<Boolean> test = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * ID of the Carrier Account object to use as the default for all shipments in this Batch. 
         * The carrier account can be changed on a per-shipment basis by changing the carrier_account in the 
         * corresponding BatchShipment object.
         */
        public Builder defaultCarrierAccount(String defaultCarrierAccount) {
            Utils.checkNotNull(defaultCarrierAccount, "defaultCarrierAccount");
            this.defaultCarrierAccount = defaultCarrierAccount;
            return this;
        }

        /**
         * Token of the service level to use as the default for all shipments in this Batch. 
         * The servicelevel can be changed on a per-shipment basis by changing the servicelevel_token in the 
         * corresponding BatchShipment object. &lt;a href="#tag/Service-Levels"&gt;Servicelevel tokens can be found here.&lt;/a&gt;
         */
        public Builder defaultServicelevelToken(String defaultServicelevelToken) {
            Utils.checkNotNull(defaultServicelevelToken, "defaultServicelevelToken");
            this.defaultServicelevelToken = defaultServicelevelToken;
            return this;
        }

        /**
         * Print format of the &lt;a href="https://docs.goshippo.com/docs/shipments/shippinglabelsizes/"&gt;label&lt;/a&gt;. If empty, will use the default format set from 
         * &lt;a href="https://apps.goshippo.com/settings/labels"&gt;the Shippo dashboard.&lt;/a&gt;
         */
        public Builder labelFiletype(LabelFileTypeEnum labelFiletype) {
            Utils.checkNotNull(labelFiletype, "labelFiletype");
            this.labelFiletype = Optional.ofNullable(labelFiletype);
            return this;
        }

        /**
         * Print format of the &lt;a href="https://docs.goshippo.com/docs/shipments/shippinglabelsizes/"&gt;label&lt;/a&gt;. If empty, will use the default format set from 
         * &lt;a href="https://apps.goshippo.com/settings/labels"&gt;the Shippo dashboard.&lt;/a&gt;
         */
        public Builder labelFiletype(Optional<? extends LabelFileTypeEnum> labelFiletype) {
            Utils.checkNotNull(labelFiletype, "labelFiletype");
            this.labelFiletype = labelFiletype;
            return this;
        }

        /**
         * A string of up to 100 characters that can be filled with any additional information you want to attach to the object.
         */
        public Builder metadata(String metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }

        /**
         * A string of up to 100 characters that can be filled with any additional information you want to attach to the object.
         */
        public Builder metadata(Optional<String> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        public Builder batchShipments(BatchShipmentPaginatedList batchShipments) {
            Utils.checkNotNull(batchShipments, "batchShipments");
            this.batchShipments = batchShipments;
            return this;
        }

        /**
         * An array of URLs each pointing to a merged file of 100 labels each
         */
        public Builder labelUrl(List<String> labelUrl) {
            Utils.checkNotNull(labelUrl, "labelUrl");
            this.labelUrl = labelUrl;
            return this;
        }

        /**
         * Date and time of Batch creation
         */
        public Builder objectCreated(String objectCreated) {
            Utils.checkNotNull(objectCreated, "objectCreated");
            this.objectCreated = objectCreated;
            return this;
        }

        /**
         * Unique identifier of the given Batch object
         */
        public Builder objectId(String objectId) {
            Utils.checkNotNull(objectId, "objectId");
            this.objectId = objectId;
            return this;
        }

        /**
         * Username of the user who created the Address object.
         */
        public Builder objectOwner(String objectOwner) {
            Utils.checkNotNull(objectOwner, "objectOwner");
            this.objectOwner = objectOwner;
            return this;
        }

        /**
         * An object containing the following counts:&lt;br&gt;`creation_succeeded`&lt;br&gt;`creation_failed`&lt;br&gt;`purchase_succeeded`&lt;br&gt;`purchase_failed`
         */
        public Builder objectResults(ObjectResults objectResults) {
            Utils.checkNotNull(objectResults, "objectResults");
            this.objectResults = objectResults;
            return this;
        }

        /**
         * Date and time of last update to the Batch
         */
        public Builder objectUpdated(String objectUpdated) {
            Utils.checkNotNull(objectUpdated, "objectUpdated");
            this.objectUpdated = objectUpdated;
            return this;
        }

        /**
         * Batches that are `VALIDATING` are being created and validated&lt;br&gt;
         * `VALID` batches can be purchased&lt;br&gt;
         * `INVALID` batches cannot be purchased, `INVALID` BatchShipments must be removed&lt;br&gt;
         * Batches that are in the `PURCHASING` state are being purchased&lt;br&gt;
         * `PURCHASED` batches are finished purchasing.
         */
        public Builder status(BatchStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        public Builder test(boolean test) {
            Utils.checkNotNull(test, "test");
            this.test = Optional.ofNullable(test);
            return this;
        }

        public Builder test(Optional<Boolean> test) {
            Utils.checkNotNull(test, "test");
            this.test = test;
            return this;
        }
        
        public Batch build() {
            return new Batch(
                defaultCarrierAccount,
                defaultServicelevelToken,
                labelFiletype,
                metadata,
                batchShipments,
                labelUrl,
                objectCreated,
                objectId,
                objectOwner,
                objectResults,
                objectUpdated,
                status,
                test);
        }
    }
}

